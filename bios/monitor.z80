BUFFER		= 0x2020
ADDR_START      = 0x20a0
ADDR_END        = 0x20a2
DATA            = 0x20a4
COMMAND         = 0x20a5  ; R - read, W - write, I - I/O input, O - I/O output, J - jump to

BACKSPACE	= 8
DEL		= 127
CR              = 10
ENTER		= 13

INVALID_HEX	= 0xff

	;-------------------
	; LINE INPUT
	;-------------------

monitor:
	; TODO - print welcome message

start:
	ld	a, 'R'			; default command: read
	ld	(COMMAND), a

	ld	hl, BUFFER
	ld      a, '*'			; print prompt
	rst	SYS_PRINT
	ld      a, ' '
	rst	SYS_PRINT

	;
	; get the next char from UART
	;

nextchr:
	in	a, (UART_CONFIG)	; key pressed?
	and	UART_INPUT_MSK
	jr	z, nextchr

	in	a, (UART)		; get key pressed

	cp	BACKSPACE		; is BACKSPACE?
	jr	z, backspace
	cp	DEL
	jr	z, backspace

	ld	b, a			; check if the line has less than 127 characters
	ld	a, l
	cp	128
	jr	c, .has_space
	jr	nextchr
.has_space:
	ld	a, b

	rst	SYS_PRINT		; print key pressed
	ld	(hl), a			; add to buffer
	inc	hl
	
	cp	ENTER  			; is ENTER?
	jr	z, enter

	jr	nextchr			; otherwise, continue

	;
	; deal with BACKSPACE
	;

backspace:
	ld	a, l			; check if first char, return
	cp	BUFFER & 0xff
	jr	z, nextchr

	ld	a, BACKSPACE		; erase last char
	rst	SYS_PRINT
	ld	a, ' '
	rst	SYS_PRINT
	ld	a, BACKSPACE
	rst	SYS_PRINT
	dec	hl			; decrement buffer
	jr	nextchr


	; 
	; deal with ENTER (start processing)
	;

enter:
	ld	a, CR			; print CR
	rst	SYS_PRINT

	; 
	; convert buffer to uppercase
	;

buffer_to_upper:
	ld	hl, BUFFER		; go through all the buffer
.next:
	ld	a, (hl)
	
	cp	a, ENTER		; if ENTER, bail out
	jr	z, .done
	
	cp	'a'			; if < 'a', skip it
	jr	c, .skip

	sub	32			; convert to uppercase (ex. 'a' - 32 = 'A')
	ld	(hl), a

.skip:
	inc	hl			; increase pointer and do for the next char
	jr	.next
.done:

	;-------------------
	; INPUT PROCESSING
	;-------------------

process_input:
	ld	de, BUFFER		; DE = buffer pointer

	call	skip_spaces

	jp	process_addr_start

	;
	; process ADDR_START
	;

process_addr_start:

	call	process_hex_str		; process the next hex value (response in HL)
	ld	(ADDR_START), hl	; if it's just a single value, set it as start and end
	ld	(ADDR_END), hl

	call	skip_spaces
	inc	de

	cp	ENTER			; if next key is ENTER, print RAM contents
	jp	z, print_ram

	cp	'.'			; if next key is '.', get end address
	jp	z, process_addr_end

	jp	syntax_error		; otherwise, syntax error

process_addr_end:
	
	call	process_hex_str		; process ending address
	ld	(ADDR_END), hl

	call	skip_spaces		

	cp	ENTER			; if next key is ENTER, print RAM contents
	jp	z, print_ram

	jp	syntax_error		; otherwise, syntax error

	;
	; subroutine - skip spaces in buffer
	;

skip_spaces:
	ld	a, (de)
	cp	a, ' '
	ret	nz
	inc	de
	jr	skip_spaces

	; 
	; process hex string
	;   IN/OUT: HL (current buffer ptr)
	;   OUT:    DE (computed hex value)
	;

process_hex_str:

	ld	hl, 0			; HL = current value
	ld	a, 0

.next_char:
	add	hl, hl			; HL <<= 4
	add	hl, hl
	add	hl, hl
	add	hl, hl
	or	l			; HL |= A
	ld	l, a

	ld	a, (de)			; A = current character

	call	hex_to_dec		; convert from hex to dec
					; A = converted character

	cp	INVALID_HEX		; character is not valid - finalize processing
	ret	z

	inc	de

	jr	.next_char


	;
	; subroutine - convert hex char (in A) to number (in A)
	;

hex_to_dec:
	cp	'0'			; check if its a number
	jr	c, .not_a_number
	cp	'9' + 1
	jr	nc, .not_a_number

	sub	'0'			; return converted value
	ret
	
.not_a_number:
	cp	'A'			; check if its a letter
	jr	c, .not_a_letter
	cp	'F' + 1
	jr	nc, .not_a_letter
	
	sub	'A' - 0xA		; return converted value
	ret

.not_a_letter
	ld	a, INVALID_HEX
	ret


	;-------------------
	; EXECUTE REQUEST
	;-------------------

	;
	; print RAM data (ADDR_START~ADDR_END)
	;

print_ram:
	ld	hl, (ADDR_START)
	ld	b, 4
	call	print_hex

	ld	a, ':'
	rst	SYS_PRINT
	ld	a, ' '
	rst	SYS_PRINT

	ld	l, (hl)
	ld	b, 2
	call	print_hex

	call	print_enter

	jp	start


	;
	; print hex value (HL) with (B) digits (2 or 4)
	;

print_hex:
	ld	a, b			; if only 2 digits, skip
	cp	2
	jr	z, .only_2_digits

	ld	a, h			; get lower byte
	ld	c, a			; save A
	repeat 4			; rotate to lower nibble
	rra	
	endrepeat
	call	print_nibble		; print lower nibble

	ld	a, c			; restore A
	call	print_nibble		; print lower nibble

.only_2_digits:
	ld	a, l			; get upper byte
	ld	c, a			; save A
	repeat 4			; rotate to upper nibble
	rra	
	endrepeat
	call	print_nibble		; print upper nibble

	ld	a, c			; restore A
	call	print_nibble		; print lower nibble

	ret

	;
	; print hex value of nibble in A
	;

print_nibble:
	and	0xf

	cp	0xa			; swap nibble for character
	jr	c, .is_number
	add	7
.is_number:
	add	'0'

	rst	SYS_PRINT		; print character

	ret

	;
	; subroutine - print ENTER
	;

print_enter:
	ld	a, CR
	rst	SYS_PRINT
	ld	a, ENTER
	rst	SYS_PRINT
	ret

	;
	; show error message
	;

syntax_error:
	ld	a, '/'
	rst	SYS_PRINT
	call	print_enter
	jp	start
	

; vim:ts=8:sw=8:sts=8:noexpandtab
