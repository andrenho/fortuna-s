BUFFER		= 0x2000
ADDR_START      = 0x2080
ADDR_END        = 0x2082
DATA            = 0x2084
COMMAND         = 0x2085

BACKSPACE	= 8
CR              = 10
ENTER		= 13

start:
	ld	hl, BUFFER
	ld      a, '*'			; print prompt
	out     (UART), a
	ld      a, ' '
	out     (UART), a

nextchr:
	in	a, (UART_CONFIG)	; key pressed?
	and	UART_INPUT_MSK
	jr	z, nextchr

	in	a, (UART)		; get key pressed

	cp	BACKSPACE		; is BACKSPACE?
	jr	z, backspace

	ld	b, a			; check if the line has less than 127 characters
	ld	a, l
	cp	128
	jr	c, .has_space
	jr	nextchr
.has_space:
	ld	a, b

	out	(UART), a		; print key pressed
	ld	(hl), a			; add to buffer
	inc	hl
	
	cp	ENTER  			; is ENTER?
	jr	z, enter

	jr	nextchr			; otherwise, continue


backspace:
	ld	a, l			; check if L == 0, return
	or	a
	jr	z, nextchr

	ld	a, BACKSPACE		; erase last char
	out	(UART), a
	ld	a, ' '
	out	(UART), a
	ld	a, BACKSPACE
	out	(UART), a
	dec	hl			; decrement buffer
	jr	nextchr


enter:
	ld	a, CR			; print CR
	out	(UART), a

buffer_to_upper:
	ld	hl, BUFFER		; go through all the buffer
.next:
	ld	a, (hl)
	
	cp	a, ENTER		; if ENTER, bail out
	jr	z, .done
	
	cp	'a'			; if < 'a', skip it
	jr	c, .skip

	sub	32			; convert to uppercase (ex. 'a' - 32 = 'A')
	ld	(hl), a

.skip:
	inc	hl			; increase pointer and do for the next char
	jr	.next

.done:


	jr	start


; vim:ts=8:sw=8:sts=8:noexpandtab
