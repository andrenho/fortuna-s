BUFFER		= 0x2020
ADDR_START      = 0x20a0
ADDR_END        = 0x20a2
DATA            = 0x20a4
COMMAND         = 0x20a5

BACKSPACE	= 8
CR              = 10
ENTER		= 13

INVALID_HEX	= 0xff

	ld	hl, $a1b2
	ld	b, 4
	call	print_hex

start:
	ld	hl, BUFFER
	ld      a, '*'			; print prompt
	out     (UART), a
	ld      a, ' '
	out     (UART), a

	;
	; get the next char from UART
	;

nextchr:
	in	a, (UART_CONFIG)	; key pressed?
	and	UART_INPUT_MSK
	jr	z, nextchr

	in	a, (UART)		; get key pressed

	cp	BACKSPACE		; is BACKSPACE?
	jr	z, backspace

	ld	b, a			; check if the line has less than 127 characters
	ld	a, l
	cp	128
	jr	c, .has_space
	jr	nextchr
.has_space:
	ld	a, b

	out	(UART), a		; print key pressed
	ld	(hl), a			; add to buffer
	inc	hl
	
	cp	ENTER  			; is ENTER?
	jr	z, enter

	jr	nextchr			; otherwise, continue

	;
	; deal with BACKSPACE
	;

backspace:
	ld	a, l			; check if L == 0, return
	or	a
	jr	z, nextchr

	ld	a, BACKSPACE		; erase last char
	out	(UART), a
	ld	a, ' '
	out	(UART), a
	ld	a, BACKSPACE
	out	(UART), a
	dec	hl			; decrement buffer
	jr	nextchr


	; 
	; deal with ENTER (start processing)
	;

enter:
	ld	a, CR			; print CR
	out	(UART), a

	; 
	; convert buffer to uppercase
	;

buffer_to_upper:
	ld	hl, BUFFER		; go through all the buffer
.next:
	ld	a, (hl)
	
	cp	a, ENTER		; if ENTER, bail out
	jr	z, .done
	
	cp	'a'			; if < 'a', skip it
	jr	c, .skip

	sub	32			; convert to uppercase (ex. 'a' - 32 = 'A')
	ld	(hl), a

.skip:
	inc	hl			; increase pointer and do for the next char
	jr	.next
.done:

	;
	; process input
	;

process_input:
	ld	de, BUFFER		; DE = buffer pointer

	call	process_hex_str		; process the next hex value (response in HL)

					; TODO - check for dot, colon, space

	ld	(ADDR_START), hl	; if it's just a single value, set it as start and end
	ld	(ADDR_END), hl

	call	print_ram		; print RAM values

	jp	start

	; 
	; process hex string
	;   IN/OUT: HL (current buffer ptr)
	;   OUT:    DE (computed hex value)
	;
process_hex_str:

	ld	hl, 0			; HL = current value
	ld	a, 0

.next_char:
	add	hl, hl			; HL <<= 4
	add	hl, hl
	add	hl, hl
	add	hl, hl
	or	l			; HL |= A
	ld	l, a

	ld	a, (de)			; A = current character

	call	hex_to_dec		; convert from hex to dec
					; A = converted character

	cp	INVALID_HEX		; character is not valid - finalize processing
	ret	z

	inc	de

	jr	.next_char

	;
	; print RAM data (ADDR_START~ADDR_END)
	;
print_ram:
	jp	$


	;
	; subroutine - convert hex char (in A) to number (in A)
	;
hex_to_dec:
	cp	'0'			; check if its a number
	jr	c, .not_a_number
	cp	'9' + 1
	jr	nc, .not_a_number

	sub	'0'			; return converted value
	ret
	
.not_a_number:
	cp	'A'			; check if its a letter
	jr	c, .not_a_letter
	cp	'F' + 1
	jr	nc, .not_a_letter
	
	sub	'A' - 0xA		; return converted value
	ret

.not_a_letter
	ld	a, INVALID_HEX
	ret

	;
	; print hex value (HL) with (B) digits (2 or 4)
	;
print_hex:
	ld	a, b			; if 2 digits, skip
	cp	2
	jp	z, .print_2_digits

	ld	a, h
	repeat 4
	rra	
	endrepeat
	call	print_nibble
	repeat 4
	rra
	endrepeat
	call	print_nibble

.print_2_digits:
	ld	a, l
	repeat 4
	rra
	endrepeat
	call	print_nibble
	repeat 4
	rra
	endrepeat
	call	print_nibble

	ret

	;
	; print hex value of nibble in A
	;
print_nibble:
	and	0xf

	cp	0xa			; swap nibble for character
	jr	c, .is_number
	add	7
.is_number:
	add	'0'

	out	(UART), a		; print character

	ret

	;
	; subroutine - print ENTER
	;

print_enter:
	ld	a, CR
	out	(UART), a
	ld	a, ENTER
	out	(UART), a
	ret

	;
	; show error message
	;

syntax_error:
	ld	a, '/'
	out	(UART), a
	call	print_enter
	jp	start
	

; vim:ts=8:sw=8:sts=8:noexpandtab
